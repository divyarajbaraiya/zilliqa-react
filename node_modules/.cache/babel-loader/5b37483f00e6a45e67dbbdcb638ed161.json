{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@zilliqa-js/util'), require('elliptic'), require('hash.js'), require('hmac-drbg'), require('scryptsy'), require('aes-js'), require('pbkdf2'), require('uuid')) : typeof define === 'function' && define.amd ? define(['exports', '@zilliqa-js/util', 'elliptic', 'hash.js', 'hmac-drbg', 'scryptsy', 'aes-js', 'pbkdf2', 'uuid'], factory) : factory(global.zjsCrypto = {}, global['@zilliqa-js/util'], global.elliptic, global.hash.js, global['hmac-drbg'], global.scryptsy, global['aes-js'], global.pbkdf2, global.uuid);\n})(this, function (exports, util, elliptic, hashjs, DRBG, scryptsy, aes, pbkdf2, uuid) {\n  'use strict';\n\n  elliptic = elliptic && elliptic.hasOwnProperty('default') ? elliptic['default'] : elliptic;\n  hashjs = hashjs && hashjs.hasOwnProperty('default') ? hashjs['default'] : hashjs;\n  DRBG = DRBG && DRBG.hasOwnProperty('default') ? DRBG['default'] : DRBG;\n  scryptsy = scryptsy && scryptsy.hasOwnProperty('default') ? scryptsy['default'] : scryptsy;\n  aes = aes && aes.hasOwnProperty('default') ? aes['default'] : aes;\n  uuid = uuid && uuid.hasOwnProperty('default') ? uuid['default'] : uuid; //  This file is part of Zilliqa-Javascript-Library.\n  //\n  //  This program is free software: you can redistribute it and/or modify\n  //  it under the terms of the GNU General Public License as published by\n  //  the Free Software Foundation, either version 3 of the License, or\n  //  (at your option) any later version.\n  //\n  //   This program is distributed in the hope that it will be useful,\n  //   but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //   GNU General Public License for more details.\n  //\n  //   You should have received a copy of the GNU General Public License\n  //   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n  /**\r\n   * randomBytes\r\n   *\r\n   * Uses JS-native CSPRNG to generate a specified number of bytes.\r\n   * NOTE: this method throws if no PRNG is available.\r\n   *\r\n   * @param {number} bytes\r\n   * @returns {string}\r\n   */\n\n  var randomBytes = function (bytes) {\n    var randBz;\n\n    if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n      randBz = window.crypto.getRandomValues(new Uint8Array(bytes));\n    } else if (typeof require !== 'undefined') {\n      randBz = require('crypto').randomBytes(bytes);\n    } else {\n      throw new Error('Unable to generate safe random numbers.');\n    }\n\n    var randStr = '';\n\n    for (var i = 0; i < bytes; i++) {\n      randStr += ('00' + randBz[i].toString(16)).slice(-2);\n    }\n\n    return randStr;\n  }; //  This file is part of Zilliqa-Javascript-Library.\n\n\n  var Signature = function () {\n    function Signature(options) {\n      this.r = typeof options.r === 'string' ? new util.BN(options.r, 16) : options.r;\n      this.s = typeof options.s === 'string' ? new util.BN(options.s, 16) : options.s;\n    }\n\n    return Signature;\n  }(); //  This file is part of Zilliqa-Javascript-Library.\n\n\n  var secp256k1 = elliptic.ec('secp256k1');\n  var curve = secp256k1.curve;\n  var PRIVKEY_SIZE_BYTES = 32; // Public key is a point (x, y) on the curve.\n  // Each coordinate requires 32 bytes.\n  // In its compressed form it suffices to store the x co-ordinate\n  // and the sign for y.\n  // Hence a total of 33 bytes.\n\n  var PUBKEY_COMPRESSED_SIZE_BYTES = 33; // Personalization string used for HMAC-DRBG instantiation.\n\n  var ALG = Buffer.from('Schnorr+SHA256  ', 'ascii'); // The length in bytes of the string above.\n\n  var ALG_LEN = 16; // The length in bytes of entropy inputs to HMAC-DRBG\n\n  var ENT_LEN = 32;\n  var HEX_ENC = 'hex';\n  /**\r\n   * generatePrivateKey\r\n   *\r\n   * @returns {string} - the hex-encoded private key\r\n   */\n\n  var generatePrivateKey = function () {\n    return secp256k1.genKeyPair({\n      entropy: randomBytes(secp256k1.curve.n.byteLength()),\n      entropyEnc: HEX_ENC,\n      pers: 'zilliqajs+secp256k1+SHA256'\n    }).getPrivate().toString(16, PRIVKEY_SIZE_BYTES * 2);\n  };\n  /**\r\n   * Hash (r | M).\r\n   * @param {Buffer} msg\r\n   * @param {BN} r\r\n   *\r\n   * @returns {Buffer}\r\n   */\n\n\n  var hash = function (q, pubkey, msg) {\n    var sha256 = hashjs.sha256();\n    var totalLength = PUBKEY_COMPRESSED_SIZE_BYTES * 2 + msg.byteLength; // 33 q + 33 pubkey + variable msgLen\n\n    var Q = q.toArrayLike(Buffer, 'be', 33);\n    var B = Buffer.allocUnsafe(totalLength);\n    Q.copy(B, 0);\n    pubkey.copy(B, 33);\n    msg.copy(B, 66);\n    return new util.BN(sha256.update(B).digest('hex'), 16);\n  };\n  /**\r\n   * sign\r\n   *\r\n   * @param {Buffer} msg\r\n   * @param {Buffer} key\r\n   * @param {Buffer} pubkey\r\n   *\r\n   * @returns {Signature}\r\n   */\n\n\n  var sign = function (msg, privKey, pubKey) {\n    var prv = new util.BN(privKey);\n    var drbg = getDRBG(msg);\n    var len = curve.n.byteLength();\n    var sig;\n\n    while (!sig) {\n      var k = new util.BN(drbg.generate(len));\n      sig = trySign(msg, k, prv, pubKey);\n    }\n\n    return sig;\n  };\n  /**\r\n   * trySign\r\n   *\r\n   * @param {Buffer} msg - the message to sign over\r\n   * @param {BN} k - output of the HMAC-DRBG\r\n   * @param {BN} privateKey - the private key\r\n   * @param {Buffer} pubKey - the public key\r\n   *\r\n   * @returns {Signature | null =>}\r\n   */\n\n\n  var trySign = function (msg, k, privKey, pubKey) {\n    if (privKey.isZero()) {\n      throw new Error('Bad private key.');\n    }\n\n    if (privKey.gte(curve.n)) {\n      throw new Error('Bad private key.');\n    } // 1a. check that k is not 0\n\n\n    if (k.isZero()) {\n      return null;\n    } // 1b. check that k is < the order of the group\n\n\n    if (k.gte(curve.n)) {\n      return null;\n    } // 2. Compute commitment Q = kG, where g is the base point\n\n\n    var Q = curve.g.mul(k); // convert the commitment to octets first\n\n    var compressedQ = new util.BN(Q.encodeCompressed()); // 3. Compute the challenge r = H(Q || pubKey || msg)\n    // mod reduce the r value by the order of secp256k1, n\n\n    var r = hash(compressedQ, pubKey, msg).umod(curve.n);\n    var h = r.clone();\n\n    if (h.isZero()) {\n      return null;\n    } // 4. Compute s = k - r * prv\n    // 4a. Compute r * prv\n\n\n    var s = h.imul(privKey).umod(curve.n); // 4b. Compute s = k - r * prv mod n\n\n    s = k.isub(s).umod(curve.n);\n\n    if (s.isZero()) {\n      return null;\n    }\n\n    return new Signature({\n      r: r,\n      s: s\n    });\n  };\n  /**\r\n   * Verify signature.\r\n   *\r\n   * @param {Buffer} msg\r\n   * @param {Buffer} signature\r\n   * @param {Buffer} key\r\n   *\r\n   * @returns {boolean}\r\n   *\r\n   * 1. Check if r,s is in [1, ..., order-1]\r\n   * 2. Compute Q = sG + r*kpub\r\n   * 3. If Q = O (the neutral point), return 0;\r\n   * 4. r' = H(Q, kpub, m)\r\n   * 5. return r' == r\r\n   */\n\n\n  var verify = function (msg, signature, key) {\n    var sig = new Signature(signature);\n\n    if (sig.s.isZero() || sig.r.isZero()) {\n      throw new Error('Invalid signature');\n    }\n\n    if (sig.s.isNeg() || sig.r.isNeg()) {\n      throw new Error('Invalid signature');\n    }\n\n    if (sig.s.gte(curve.n) || sig.r.gte(curve.n)) {\n      throw new Error('Invalid signature');\n    }\n\n    var kpub = curve.decodePoint(key);\n\n    if (!curve.validate(kpub)) {\n      throw new Error('Invalid public key');\n    }\n\n    var l = kpub.mul(sig.r);\n    var r = curve.g.mul(sig.s);\n    var Q = l.add(r);\n\n    if (Q.isInfinity()) {\n      throw new Error('Invalid intermediate point.');\n    }\n\n    var compressedQ = new util.BN(Q.encodeCompressed());\n    var r1 = hash(compressedQ, key, msg).umod(curve.n);\n\n    if (r1.isZero()) {\n      throw new Error('Invalid hash.');\n    }\n\n    return r1.eq(sig.r);\n  };\n\n  var toSignature = function (serialised) {\n    var r = serialised.slice(0, 64);\n    var s = serialised.slice(64);\n    return new Signature({\n      r: r,\n      s: s\n    });\n  };\n  /**\r\n   * Instantiate an HMAC-DRBG.\r\n   *\r\n   * @param {Buffer} msg - used as nonce\r\n   *\r\n   * @returns {DRBG}\r\n   */\n\n\n  var getDRBG = function (msg) {\n    var entropy = randomBytes(ENT_LEN);\n    var pers = Buffer.allocUnsafe(ALG_LEN + ENT_LEN);\n    Buffer.from(randomBytes(ENT_LEN)).copy(pers, 0);\n    ALG.copy(pers, ENT_LEN);\n    return new DRBG({\n      hash: hashjs.sha256,\n      entropy: entropy,\n      nonce: msg,\n      pers: pers\n    });\n  };\n\n  var schnorr = /*#__PURE__*/Object.freeze({\n    generatePrivateKey: generatePrivateKey,\n    hash: hash,\n    sign: sign,\n    trySign: trySign,\n    verify: verify,\n    toSignature: toSignature\n  }); //  This file is part of Zilliqa-Javascript-Library.\n  // This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n  // Copyright (c) 2017 Pieter Wuille\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a copy\n  // of this software and associated documentation files (the \"Software\"), to deal\n  // in the Software without restriction, including without limitation the rights\n  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  // copies of the Software, and to permit persons to whom the Software is\n  // furnished to do so, subject to the following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included in\n  // all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  // THE SOFTWARE.\n\n  var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n  var GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\n  var polymod = function (values) {\n    var chk = 1; // tslint:disable-next-line\n\n    for (var p = 0; p < values.length; ++p) {\n      var top_1 = chk >> 25;\n      chk = (chk & 0x1ffffff) << 5 ^ values[p];\n\n      for (var i = 0; i < 5; ++i) {\n        if (top_1 >> i & 1) {\n          chk ^= GENERATOR[i];\n        }\n      }\n    }\n\n    return chk;\n  };\n\n  var hrpExpand = function (hrp) {\n    var ret = [];\n    var p;\n\n    for (p = 0; p < hrp.length; ++p) {\n      ret.push(hrp.charCodeAt(p) >> 5);\n    }\n\n    ret.push(0);\n\n    for (p = 0; p < hrp.length; ++p) {\n      ret.push(hrp.charCodeAt(p) & 31);\n    }\n\n    return Buffer.from(ret);\n  };\n\n  function verifyChecksum(hrp, data) {\n    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n  }\n\n  function createChecksum(hrp, data) {\n    var values = Buffer.concat([Buffer.from(hrpExpand(hrp)), data, Buffer.from([0, 0, 0, 0, 0, 0])]); // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n\n    var mod = polymod(values) ^ 1;\n    var ret = [];\n\n    for (var p = 0; p < 6; ++p) {\n      ret.push(mod >> 5 * (5 - p) & 31);\n    }\n\n    return Buffer.from(ret);\n  }\n\n  var encode = function (hrp, data) {\n    var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n    var ret = hrp + '1'; // tslint:disable-next-line\n\n    for (var p = 0; p < combined.length; ++p) {\n      ret += CHARSET.charAt(combined[p]);\n    }\n\n    return ret;\n  };\n\n  var decode = function (bechString) {\n    var p;\n    var hasLower = false;\n    var hasUpper = false;\n\n    for (p = 0; p < bechString.length; ++p) {\n      if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n        return null;\n      }\n\n      if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n        hasLower = true;\n      }\n\n      if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n        hasUpper = true;\n      }\n    }\n\n    if (hasLower && hasUpper) {\n      return null;\n    }\n\n    bechString = bechString.toLowerCase();\n    var pos = bechString.lastIndexOf('1');\n\n    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n      return null;\n    }\n\n    var hrp = bechString.substring(0, pos);\n    var data = [];\n\n    for (p = pos + 1; p < bechString.length; ++p) {\n      var d = CHARSET.indexOf(bechString.charAt(p));\n\n      if (d === -1) {\n        return null;\n      }\n\n      data.push(d);\n    }\n\n    if (!verifyChecksum(hrp, Buffer.from(data))) {\n      return null;\n    }\n\n    return {\n      hrp: hrp,\n      data: Buffer.from(data.slice(0, data.length - 6))\n    };\n  }; // HRP is the human-readable part of zilliqa bech32 addresses\n\n\n  var HRP = 'zil';\n  /**\r\n   * convertBits\r\n   *\r\n   * groups buffers of a certain width to buffers of the desired width.\r\n   *\r\n   * For example, converts byte buffers to buffers of maximum 5 bit numbers,\r\n   * padding those numbers as necessary. Necessary for encoding Ethereum-style\r\n   * addresses as bech32 ones.\r\n   *\r\n   * @param {Buffer} data\r\n   * @param {number} fromWidth\r\n   * @param {number} toWidth\r\n   * @param {boolean} pad\r\n   * @returns {Buffer|null}\r\n   */\n\n  var convertBits = function (data, fromWidth, toWidth, pad) {\n    if (pad === void 0) {\n      pad = true;\n    }\n\n    var acc = 0;\n    var bits = 0;\n    var ret = [];\n    var maxv = (1 << toWidth) - 1; // tslint:disable-next-line\n\n    for (var p = 0; p < data.length; ++p) {\n      var value = data[p];\n\n      if (value < 0 || value >> fromWidth !== 0) {\n        return null;\n      }\n\n      acc = acc << fromWidth | value;\n      bits += fromWidth;\n\n      while (bits >= toWidth) {\n        bits -= toWidth;\n        ret.push(acc >> bits & maxv);\n      }\n    }\n\n    if (pad) {\n      if (bits > 0) {\n        ret.push(acc << toWidth - bits & maxv);\n      }\n    } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {\n      return null;\n    }\n\n    return Buffer.from(ret);\n  };\n  /**\r\n   * toBech32Address\r\n   *\r\n   * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\r\n   * address.\r\n   *\r\n   * The expected format is zil1<address><checksum> where address and checksum\r\n   * are the result of bech32 encoding a Buffer containing the address bytes.\r\n   *\r\n   * @param {string} 20 byte canonical address\r\n   * @returns {string} 38 char bech32 encoded zilliqa address\r\n   */\n\n\n  var toBech32Address = function (address) {\n    if (!util.validation.isAddress(address)) {\n      throw new Error('Invalid address format.');\n    }\n\n    var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n\n    if (addrBz === null) {\n      throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n    }\n\n    return encode(HRP, addrBz);\n  };\n  /**\r\n   * fromBech32Address\r\n   *\r\n   * @param {string} address - a valid Zilliqa bech32 address\r\n   * @returns {string} a canonical 20-byte Ethereum-style address\r\n   */\n\n\n  var fromBech32Address = function (address) {\n    var res = decode(address);\n\n    if (res === null) {\n      throw new Error('Invalid bech32 address');\n    }\n\n    var hrp = res.hrp,\n        data = res.data;\n    var shouldBe = HRP;\n\n    if (hrp !== shouldBe) {\n      throw new Error(\"Expected hrp to be \" + shouldBe + \" but got \" + hrp);\n    }\n\n    var buf = convertBits(data, 5, 8, false);\n\n    if (buf === null) {\n      throw new Error('Could not convert buffer to bytes');\n    }\n\n    return toChecksumAddress(buf.toString('hex'));\n  }; //  This file is part of Zilliqa-Javascript-Library.\n\n\n  var secp256k1$1 = elliptic.ec('secp256k1');\n  /**\r\n   * getAddressFromPrivateKey\r\n   *\r\n   * takes a hex-encoded string (private key) and returns its corresponding\r\n   * 20-byte hex-encoded address.\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n  var getAddressFromPrivateKey = function (privateKey) {\n    var normalizedPrviateKey = normalizePrivateKey(privateKey);\n    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');\n    var pub = keyPair.getPublic(true, 'hex');\n    return toChecksumAddress(hashjs.sha256().update(pub, 'hex').digest('hex').slice(24));\n  };\n  /**\r\n   * getPubKeyFromPrivateKey\r\n   *\r\n   * takes a hex-encoded string (private key) and returns its corresponding\r\n   * hex-encoded 33-byte public key.\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n\n  var getPubKeyFromPrivateKey = function (privateKey) {\n    var normalizedPrviateKey = normalizePrivateKey(privateKey);\n    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');\n    return keyPair.getPublic(true, 'hex');\n  };\n  /**\r\n   * getAccountFrom0xPrivateKey\r\n   *\r\n   * Utility method for recovering account from 0x private key.\r\n   * See https://github.com/Zilliqa/Zilliqa-JavaScript-Library/pull/159\r\n   * @param privateKeyWith0x : private key with 0x prefix\r\n   */\n\n\n  var getAccountFrom0xPrivateKey = function (privateKeyWith0x) {\n    var privateKeyWithout0x = normalizePrivateKey(privateKeyWith0x);\n    var keyPair = secp256k1$1.keyFromPrivate(privateKeyWith0x, 'hex');\n    var publicKeyWith0x = keyPair.getPublic(true, 'hex');\n    var addressWith0x = getAddressFromPublicKey(publicKeyWith0x);\n    var bech32With0x = toBech32Address(addressWith0x);\n    var with0x = {\n      prv: privateKeyWith0x,\n      pub: publicKeyWith0x,\n      addr: addressWith0x,\n      bech32: bech32With0x\n    };\n    var keyPair2 = secp256k1$1.keyFromPrivate(privateKeyWithout0x, 'hex');\n    var publicKeyWithout0x = keyPair2.getPublic(true, 'hex');\n    var addressWithout0x = getAddressFromPublicKey(publicKeyWithout0x);\n    var bech32Without0x = toBech32Address(addressWithout0x);\n    var without0x = {\n      prv: privateKeyWithout0x,\n      pub: publicKeyWithout0x,\n      addr: addressWithout0x,\n      bech32: bech32Without0x\n    };\n    var privateKeyAfterChange = keyPair.getPrivate('hex');\n    var publicKeyAfterChange = keyPair.getPublic(true, 'hex');\n    var addressAfterChange = getAddressFromPublicKey(publicKeyAfterChange);\n    var bech32AfterChange = toBech32Address(addressAfterChange);\n    var changed = {\n      prv: privateKeyAfterChange,\n      pub: publicKeyAfterChange,\n      addr: addressAfterChange,\n      bech32: bech32AfterChange\n    };\n    return {\n      with0x: with0x,\n      without0x: without0x,\n      changed: changed\n    };\n  };\n  /**\r\n   * compressPublicKey\r\n   *\r\n   * @param {string} publicKey - 65-byte public key, a point (x, y)\r\n   *\r\n   * @returns {string}\r\n   */\n\n\n  var compressPublicKey = function (publicKey) {\n    return secp256k1$1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');\n  };\n  /**\r\n   * getAddressFromPublicKey\r\n   *\r\n   * takes hex-encoded string and returns the corresponding address\r\n   *\r\n   * @param {string} pubKey\r\n   * @returns {string}\r\n   */\n\n\n  var getAddressFromPublicKey = function (publicKey) {\n    return toChecksumAddress(hashjs.sha256().update(publicKey, 'hex').digest('hex').slice(24));\n  };\n  /**\r\n   * toChecksumAddress\r\n   *\r\n   * takes hex-encoded string and returns the corresponding address\r\n   *\r\n   * @param {string} address\r\n   * @returns {string}\r\n   */\n\n\n  var toChecksumAddress = function (address) {\n    if (!util.validation.isAddress(address)) {\n      throw new Error(address + \" is not a valid base 16 address\");\n    }\n\n    address = address.toLowerCase().replace('0x', '');\n    var hash = hashjs.sha256().update(address, 'hex').digest('hex');\n    var v = new util.BN(hash, 'hex', 'be');\n    var ret = '0x';\n\n    for (var i = 0; i < address.length; i++) {\n      if ('0123456789'.indexOf(address[i]) !== -1) {\n        ret += address[i];\n      } else {\n        ret += v.and(new util.BN(2).pow(new util.BN(255 - 6 * i))).gte(new util.BN(1)) ? address[i].toUpperCase() : address[i].toLowerCase();\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * isValidChecksumAddress\r\n   *\r\n   * takes hex-encoded string and returns boolean if address is checksumed\r\n   *\r\n   * @param {string} address\r\n   * @returns {boolean}\r\n   */\n\n\n  var isValidChecksumAddress = function (address) {\n    return util.validation.isAddress(address.replace('0x', '')) && toChecksumAddress(address) === address;\n  };\n  /**\r\n   * normaliseAddress\r\n   *\r\n   * takes in a base16 address or a zilliqa bech32 encoded address\r\n   * and returns a checksum base16 address. If the address is neither a base16\r\n   * nor bech32 address, the code will return an error\r\n   * @param {string)} address\r\n   * @returns {string}\r\n   */\n\n\n  var normaliseAddress = function (address) {\n    if (util.validation.isBech32(address)) {\n      return fromBech32Address(address);\n    }\n\n    if (!isValidChecksumAddress(address)) {\n      throw Error('Wrong address format, should be either bech32 or checksummed address');\n    }\n\n    return address;\n  };\n  /**\r\n   * encodeBase58\r\n   *\r\n   * @param {string} hex - base 16 encoded string\r\n   * @returns {string} - big endian base 58 encoded string\r\n   */\n\n\n  var encodeBase58 = function (hex) {\n    var clean = hex.toLowerCase().replace('0x', '');\n    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    var base = new util.BN(58);\n    var zero = new util.BN(0);\n    var x = new util.BN(clean, 16);\n    var res = '';\n\n    while (x.gt(zero)) {\n      var rem = x.mod(base).toNumber(); // safe, always < 58\n      // big endian\n\n      res = tbl[rem] + res; // quotient, remainders thrown away in integer division\n\n      x = x.div(base);\n    } // convert to big endian in case the input hex is little endian\n\n\n    var hexBE = x.toString('hex', clean.length);\n\n    for (var i = 0; i < hexBE.length; i += 2) {\n      if (hex[i] === '0' && hex[i + 1] === '0') {\n        res = tbl[0] + res;\n      } else {\n        break;\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * decodeBase58\r\n   *\r\n   * @param {string} raw - base 58 string\r\n   * @returns {string} - big endian base 16 string\r\n   */\n\n\n  var decodeBase58 = function (raw) {\n    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    var base = new util.BN(58);\n    var zero = new util.BN(0);\n    var isBreak = false;\n    var n = new util.BN(0);\n    var leader = '';\n\n    for (var i = 0; i < raw.length; i++) {\n      var char = raw.charAt(i);\n      var weight = new util.BN(tbl.indexOf(char));\n      n = n.mul(base).add(weight); // check if padding required\n\n      if (!isBreak) {\n        if (i - 1 > 0 && raw[i - 1] !== '1') {\n          isBreak = true;\n          continue;\n        }\n\n        if (char === '1') {\n          leader += '00';\n        }\n      }\n    }\n\n    if (n.eq(zero)) {\n      return leader;\n    }\n\n    var res = leader + n.toString('hex');\n\n    if (res.length % 2 !== 0) {\n      res = '0' + res;\n    }\n\n    return res;\n  };\n  /**\r\n   * verifyPrivateKey\r\n   *\r\n   * @param {string|Buffer} privateKey\r\n   * @returns {boolean}\r\n   */\n\n\n  var verifyPrivateKey = function (privateKey) {\n    var keyPair = secp256k1$1.keyFromPrivate(privateKey, 'hex');\n    var result = keyPair.validate().result;\n    return result;\n  };\n  /**\r\n   * normalizePrivateKey : normalise private key from 0x or without 0x prefix\r\n   *\r\n   * @param {string} privateKey\r\n   * @returns {string}\r\n   */\n\n\n  var normalizePrivateKey = function (privateKey) {\n    try {\n      if (!util.validation.isPrivateKey(privateKey)) {\n        throw new Error('Private key is not correct');\n      }\n\n      var normalized = privateKey.toLowerCase().replace('0x', '');\n\n      if (!verifyPrivateKey(normalized)) {\n        throw new Error('Private key is not correct');\n      }\n\n      return normalized;\n    } catch (error) {\n      throw error;\n    }\n  };\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n\n  function __awaiter(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n\n  function __generator(thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  }\n\n  var js = scryptsy; //  This file is part of Zilliqa-Javascript-Library.\n\n  var ALGO_IDENTIFIER = 'aes-128-ctr';\n  /**\r\n   * getDerivedKey\r\n   *\r\n   * NOTE: only scrypt and pbkdf2 are supported.\r\n   *\r\n   * @param {Buffer} key - the passphrase\r\n   * @param {KDF} kdf - the key derivation function to be used\r\n   * @param {KDFParams} params - params for the kdf\r\n   *\r\n   * @returns {Promise<Buffer>}\r\n   */\n\n  function getDerivedKey(key, kdf, params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var salt, _a, c, dklen, _b, n, r, p, dklen;\n\n      return __generator(this, function (_c) {\n        salt = Buffer.from(params.salt, 'hex');\n\n        if (kdf === 'pbkdf2') {\n          _a = params, c = _a.c, dklen = _a.dklen;\n          return [2\n          /*return*/\n          , pbkdf2.pbkdf2Sync(key, salt, c, dklen, 'sha256')];\n        }\n\n        if (kdf === 'scrypt') {\n          _b = params, n = _b.n, r = _b.r, p = _b.p, dklen = _b.dklen;\n          return [2\n          /*return*/\n          , js(key, salt, n, r, p, dklen)];\n        }\n\n        throw new Error('Only pbkdf2 and scrypt are supported');\n      });\n    });\n  }\n  /**\r\n   * encryptPrivateKey\r\n   *\r\n   * Encodes and encrypts an account in the format specified by\r\n   * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition.\r\n   * However, note that, in keeping with the hash function used by Zilliqa's\r\n   * core protocol, the MAC is generated using sha256 instead of keccak.\r\n   *\r\n   * NOTE: only scrypt and pbkdf2 are supported.\r\n   *\r\n   * @param {KDF} kdf - the key derivation function to be used\r\n   * @param {string} privateKey - hex-encoded private key\r\n   * @param {string} passphrase - a passphrase used for encryption\r\n   *\r\n   * @returns {Promise<string>}\r\n   */\n\n\n  var encryptPrivateKey = function (kdf, privateKey, passphrase) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var address, salt, iv, kdfparams, derivedKey, cipher, ciphertext;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            address = getAddressFromPrivateKey(privateKey);\n            salt = randomBytes(32);\n            iv = Buffer.from(randomBytes(16), 'hex');\n            kdfparams = {\n              salt: salt,\n              n: 8192,\n              c: 262144,\n              r: 8,\n              p: 1,\n              dklen: 32\n            };\n            return [4\n            /*yield*/\n            , getDerivedKey(Buffer.from(passphrase), kdf, kdfparams)];\n\n          case 1:\n            derivedKey = _a.sent();\n            cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n            ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey, 'hex')));\n            return [2\n            /*return*/\n            , JSON.stringify({\n              address: address,\n              crypto: {\n                cipher: ALGO_IDENTIFIER,\n                cipherparams: {\n                  iv: iv.toString('hex')\n                },\n                ciphertext: ciphertext.toString('hex'),\n                kdf: kdf,\n                kdfparams: kdfparams,\n                mac: hashjs // @ts-ignore\n                .hmac(hashjs.sha256, derivedKey, 'hex').update(Buffer.concat([derivedKey.slice(16, 32), ciphertext, iv, Buffer.from(ALGO_IDENTIFIER)]), 'hex').digest('hex')\n              },\n              id: uuid.v4({\n                random: util.bytes.hexToIntArray(randomBytes(16))\n              }),\n              version: 3\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * decryptPrivateKey\r\n   *\r\n   * Recovers the private key from a keystore file using the given passphrase.\r\n   *\r\n   * @param {string} passphrase\r\n   * @param {KeystoreV3} keystore\r\n   * @returns {Promise<string>}\r\n   */\n\n\n  var decryptPrivateKey = function (passphrase, keystore) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var ciphertext, iv, kdfparams, derivedKey, mac, cipher;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n            iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n            kdfparams = keystore.crypto.kdfparams;\n            return [4\n            /*yield*/\n            , getDerivedKey(Buffer.from(passphrase), keystore.crypto.kdf, kdfparams)];\n\n          case 1:\n            derivedKey = _a.sent();\n            mac = hashjs // @ts-ignore\n            .hmac(hashjs.sha256, derivedKey, 'hex').update(Buffer.concat([derivedKey.slice(16, 32), ciphertext, iv, Buffer.from(ALGO_IDENTIFIER)]), 'hex').digest('hex'); // we need to do a byte-by-byte comparison to avoid non-constant time side\n            // channel attacks.\n\n            if (!util.bytes.isEqual(mac.toUpperCase(), keystore.crypto.mac.toUpperCase())) {\n              return [2\n              /*return*/\n              , Promise.reject('Failed to decrypt.')];\n            }\n\n            cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));\n            return [2\n            /*return*/\n            , Buffer.from(cipher.decrypt(ciphertext)).toString('hex')];\n        }\n      });\n    });\n  }; //  This file is part of Zilliqa-Javascript-Library.\n\n  /**\r\n   * sign\r\n   *\r\n   * @param {string} hash - hex-encoded hash of the data to be signed\r\n   *\r\n   * @returns {string} the signature\r\n   */\n\n\n  var sign$1 = function (msg, privateKey, pubKey) {\n    var sig = sign(msg, Buffer.from(privateKey, 'hex'), Buffer.from(pubKey, 'hex'));\n    var r = sig.r.toString('hex');\n    var s = sig.s.toString('hex');\n\n    while (r.length < 64) {\n      r = '0' + r;\n    }\n\n    while (s.length < 64) {\n      s = '0' + s;\n    }\n\n    return r + s;\n  };\n\n  exports.sign = sign$1;\n  exports.schnorr = schnorr;\n  exports.getAddressFromPrivateKey = getAddressFromPrivateKey;\n  exports.getPubKeyFromPrivateKey = getPubKeyFromPrivateKey;\n  exports.getAccountFrom0xPrivateKey = getAccountFrom0xPrivateKey;\n  exports.compressPublicKey = compressPublicKey;\n  exports.getAddressFromPublicKey = getAddressFromPublicKey;\n  exports.toChecksumAddress = toChecksumAddress;\n  exports.isValidChecksumAddress = isValidChecksumAddress;\n  exports.normaliseAddress = normaliseAddress;\n  exports.encodeBase58 = encodeBase58;\n  exports.decodeBase58 = decodeBase58;\n  exports.verifyPrivateKey = verifyPrivateKey;\n  exports.normalizePrivateKey = normalizePrivateKey;\n  exports.encryptPrivateKey = encryptPrivateKey;\n  exports.decryptPrivateKey = decryptPrivateKey;\n  exports.randomBytes = randomBytes;\n  exports.Signature = Signature;\n  exports.encode = encode;\n  exports.decode = decode;\n  exports.HRP = HRP;\n  exports.convertBits = convertBits;\n  exports.toBech32Address = toBech32Address;\n  exports.fromBech32Address = fromBech32Address;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/random.ts","../src/signature.ts","../src/schnorr.ts","../src/bech32.ts","../src/util.ts","../../../node_modules/tslib/tslib.es6.js","../../../node_modules/scrypt.js/js.js","../src/keystore.ts","../src/index.ts"],"names":["BN","validation","secp256k1","require$$0","pbkdf2Sync","scrypt","bytes","sign","schnorr.sign"],"mappings":"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","sourcesContent":["//  This file is part of Zilliqa-Javascript-Library.\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public License\n//   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * randomBytes\n *\n * Uses JS-native CSPRNG to generate a specified number of bytes.\n * NOTE: this method throws if no PRNG is available.\n *\n * @param {number} bytes\n * @returns {string}\n */\nexport const randomBytes = (bytes: number) => {\n  let randBz: number[] | Uint8Array;\n\n  if (\n    typeof window !== 'undefined' &&\n    window.crypto &&\n    window.crypto.getRandomValues\n  ) {\n    randBz = window.crypto.getRandomValues(new Uint8Array(bytes));\n  } else if (typeof require !== 'undefined') {\n    randBz = require('crypto').randomBytes(bytes);\n  } else {\n    throw new Error('Unable to generate safe random numbers.');\n  }\n\n  let randStr = '';\n  for (let i = 0; i < bytes; i++) {\n    randStr += ('00' + randBz[i].toString(16)).slice(-2);\n  }\n\n  return randStr;\n};\n","//  This file is part of Zilliqa-Javascript-Library.\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public License\n//   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { BN } from '@zilliqa-js/util';\n\n/**\n * Signature\n *\n * This replaces `elliptic/lib/elliptic/ec/signature`. This is to avoid\n * duplicate code in the final bundle, caused by having to bundle elliptic\n * twice due to its circular dependencies. This can be removed once\n * https://github.com/indutny/elliptic/pull/157 is resolved, or we find the\n * time to fork an optimised version of the library.\n */\ninterface SignatureOpt {\n  r: string | BN;\n  s: string | BN;\n}\n\nexport class Signature {\n  r: BN;\n  s: BN;\n\n  constructor(options: SignatureOpt) {\n    this.r = typeof options.r === 'string' ? new BN(options.r, 16) : options.r;\n    this.s = typeof options.s === 'string' ? new BN(options.s, 16) : options.s;\n  }\n}\n","//  This file is part of Zilliqa-Javascript-Library.\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public License\n//   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport elliptic from 'elliptic';\nimport hashjs from 'hash.js';\nimport DRBG from 'hmac-drbg';\n\nimport { BN } from '@zilliqa-js/util';\n\nimport { randomBytes } from './random';\nimport { Signature } from './signature';\n\nconst secp256k1 = elliptic.ec('secp256k1');\nconst curve = secp256k1.curve;\nconst PRIVKEY_SIZE_BYTES = 32;\n// Public key is a point (x, y) on the curve.\n// Each coordinate requires 32 bytes.\n// In its compressed form it suffices to store the x co-ordinate\n// and the sign for y.\n// Hence a total of 33 bytes.\nconst PUBKEY_COMPRESSED_SIZE_BYTES = 33;\n// Personalization string used for HMAC-DRBG instantiation.\nconst ALG = Buffer.from('Schnorr+SHA256  ', 'ascii');\n// The length in bytes of the string above.\nconst ALG_LEN = 16;\n// The length in bytes of entropy inputs to HMAC-DRBG\nconst ENT_LEN = 32;\n\nconst HEX_ENC: 'hex' = 'hex';\n\n/**\n * generatePrivateKey\n *\n * @returns {string} - the hex-encoded private key\n */\nexport const generatePrivateKey = (): string => {\n  return secp256k1\n    .genKeyPair({\n      entropy: randomBytes(secp256k1.curve.n.byteLength()),\n      entropyEnc: HEX_ENC,\n      pers: 'zilliqajs+secp256k1+SHA256',\n    })\n    .getPrivate()\n    .toString(16, PRIVKEY_SIZE_BYTES * 2);\n};\n\n/**\n * Hash (r | M).\n * @param {Buffer} msg\n * @param {BN} r\n *\n * @returns {Buffer}\n */\n\nexport const hash = (q: BN, pubkey: Buffer, msg: Buffer) => {\n  const sha256 = hashjs.sha256();\n  const totalLength = PUBKEY_COMPRESSED_SIZE_BYTES * 2 + msg.byteLength; // 33 q + 33 pubkey + variable msgLen\n  const Q = q.toArrayLike(Buffer, 'be', 33);\n  const B = Buffer.allocUnsafe(totalLength);\n\n  Q.copy(B, 0);\n  pubkey.copy(B, 33);\n  msg.copy(B, 66);\n\n  return new BN(sha256.update(B).digest('hex'), 16);\n};\n\n/**\n * sign\n *\n * @param {Buffer} msg\n * @param {Buffer} key\n * @param {Buffer} pubkey\n *\n * @returns {Signature}\n */\nexport const sign = (\n  msg: Buffer,\n  privKey: Buffer,\n  pubKey: Buffer,\n): Signature => {\n  const prv = new BN(privKey);\n  const drbg = getDRBG(msg);\n  const len = curve.n.byteLength();\n\n  let sig;\n  while (!sig) {\n    const k = new BN(drbg.generate(len));\n    sig = trySign(msg, k, prv, pubKey);\n  }\n\n  return sig;\n};\n\n/**\n * trySign\n *\n * @param {Buffer} msg - the message to sign over\n * @param {BN} k - output of the HMAC-DRBG\n * @param {BN} privateKey - the private key\n * @param {Buffer} pubKey - the public key\n *\n * @returns {Signature | null =>}\n */\nexport const trySign = (\n  msg: Buffer,\n  k: BN,\n  privKey: BN,\n  pubKey: Buffer,\n): Signature | null => {\n  if (privKey.isZero()) {\n    throw new Error('Bad private key.');\n  }\n\n  if (privKey.gte(curve.n)) {\n    throw new Error('Bad private key.');\n  }\n\n  // 1a. check that k is not 0\n  if (k.isZero()) {\n    return null;\n  }\n  // 1b. check that k is < the order of the group\n  if (k.gte(curve.n)) {\n    return null;\n  }\n\n  // 2. Compute commitment Q = kG, where g is the base point\n  const Q = curve.g.mul(k);\n  // convert the commitment to octets first\n  const compressedQ = new BN(Q.encodeCompressed());\n\n  // 3. Compute the challenge r = H(Q || pubKey || msg)\n  // mod reduce the r value by the order of secp256k1, n\n  const r = hash(compressedQ, pubKey, msg).umod(curve.n);\n  const h = r.clone();\n\n  if (h.isZero()) {\n    return null;\n  }\n\n  // 4. Compute s = k - r * prv\n  // 4a. Compute r * prv\n  let s = h.imul(privKey).umod(curve.n);\n  // 4b. Compute s = k - r * prv mod n\n  s = k.isub(s).umod(curve.n);\n\n  if (s.isZero()) {\n    return null;\n  }\n\n  return new Signature({ r, s });\n};\n\n/**\n * Verify signature.\n *\n * @param {Buffer} msg\n * @param {Buffer} signature\n * @param {Buffer} key\n *\n * @returns {boolean}\n *\n * 1. Check if r,s is in [1, ..., order-1]\n * 2. Compute Q = sG + r*kpub\n * 3. If Q = O (the neutral point), return 0;\n * 4. r' = H(Q, kpub, m)\n * 5. return r' == r\n */\nexport const verify = (msg: Buffer, signature: Signature, key: Buffer) => {\n  const sig = new Signature(signature);\n\n  if (sig.s.isZero() || sig.r.isZero()) {\n    throw new Error('Invalid signature');\n  }\n\n  if (sig.s.isNeg() || sig.r.isNeg()) {\n    throw new Error('Invalid signature');\n  }\n\n  if (sig.s.gte(curve.n) || sig.r.gte(curve.n)) {\n    throw new Error('Invalid signature');\n  }\n\n  const kpub = curve.decodePoint(key);\n  if (!curve.validate(kpub)) {\n    throw new Error('Invalid public key');\n  }\n\n  const l = kpub.mul(sig.r);\n  const r = curve.g.mul(sig.s);\n\n  const Q = l.add(r);\n\n  if (Q.isInfinity()) {\n    throw new Error('Invalid intermediate point.');\n  }\n\n  const compressedQ = new BN(Q.encodeCompressed());\n\n  const r1 = hash(compressedQ, key, msg).umod(curve.n);\n\n  if (r1.isZero()) {\n    throw new Error('Invalid hash.');\n  }\n\n  return r1.eq(sig.r);\n};\n\nexport const toSignature = (serialised: string): Signature => {\n  const r = serialised.slice(0, 64);\n  const s = serialised.slice(64);\n\n  return new Signature({ r, s });\n};\n\n/**\n * Instantiate an HMAC-DRBG.\n *\n * @param {Buffer} msg - used as nonce\n *\n * @returns {DRBG}\n */\nconst getDRBG = (msg: Buffer) => {\n  const entropy = randomBytes(ENT_LEN);\n  const pers = Buffer.allocUnsafe(ALG_LEN + ENT_LEN);\n\n  Buffer.from(randomBytes(ENT_LEN)).copy(pers, 0);\n  ALG.copy(pers, ENT_LEN);\n\n  return new DRBG({\n    hash: hashjs.sha256,\n    entropy,\n    nonce: msg,\n    pers,\n  });\n};\n","//  This file is part of Zilliqa-Javascript-Library.\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public License\n//   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport { validation } from '@zilliqa-js/util';\n\nimport { toChecksumAddress } from './util';\n// This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\nconst polymod = (values: Buffer): number => {\n  let chk = 1;\n  // tslint:disable-next-line\n  for (let p = 0; p < values.length; ++p) {\n    const top = chk >> 25;\n    chk = ((chk & 0x1ffffff) << 5) ^ values[p];\n    for (let i = 0; i < 5; ++i) {\n      if ((top >> i) & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n  return chk;\n};\n\nconst hrpExpand = (hrp: string): Buffer => {\n  const ret = [];\n  let p;\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n  ret.push(0);\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return Buffer.from(ret);\n};\n\nfunction verifyChecksum(hrp: string, data: Buffer) {\n  return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\n\nfunction createChecksum(hrp: string, data: Buffer) {\n  const values = Buffer.concat([\n    Buffer.from(hrpExpand(hrp)),\n    data,\n    Buffer.from([0, 0, 0, 0, 0, 0]),\n  ]);\n  // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n  const mod = polymod(values) ^ 1;\n  const ret = [];\n  for (let p = 0; p < 6; ++p) {\n    ret.push((mod >> (5 * (5 - p))) & 31);\n  }\n  return Buffer.from(ret);\n}\n\nexport const encode = (hrp: string, data: Buffer) => {\n  const combined = Buffer.concat([data, createChecksum(hrp, data)]);\n  let ret = hrp + '1';\n  // tslint:disable-next-line\n  for (let p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n};\n\nexport const decode = (bechString: string) => {\n  let p;\n  let hasLower = false;\n  let hasUpper = false;\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n      hasLower = true;\n    }\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n      hasUpper = true;\n    }\n  }\n  if (hasLower && hasUpper) {\n    return null;\n  }\n  bechString = bechString.toLowerCase();\n  const pos = bechString.lastIndexOf('1');\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n  const hrp = bechString.substring(0, pos);\n  const data = [];\n  for (p = pos + 1; p < bechString.length; ++p) {\n    const d = CHARSET.indexOf(bechString.charAt(p));\n    if (d === -1) {\n      return null;\n    }\n    data.push(d);\n  }\n\n  if (!verifyChecksum(hrp, Buffer.from(data))) {\n    return null;\n  }\n\n  return { hrp, data: Buffer.from(data.slice(0, data.length - 6)) };\n};\n\n// HRP is the human-readable part of zilliqa bech32 addresses\nexport const HRP = 'zil';\n\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n *\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nexport const convertBits = (\n  data: Buffer,\n  fromWidth: number,\n  toWidth: number,\n  pad: boolean = true,\n) => {\n  let acc = 0;\n  let bits = 0;\n  const ret = [];\n  const maxv = (1 << toWidth) - 1;\n  // tslint:disable-next-line\n  for (let p = 0; p < data.length; ++p) {\n    const value = data[p];\n    if (value < 0 || value >> fromWidth !== 0) {\n      return null;\n    }\n    acc = (acc << fromWidth) | value;\n    bits += fromWidth;\n    while (bits >= toWidth) {\n      bits -= toWidth;\n      ret.push((acc >> bits) & maxv);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      ret.push((acc << (toWidth - bits)) & maxv);\n    }\n  } else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {\n    return null;\n  }\n\n  return Buffer.from(ret);\n};\n\n/**\n * toBech32Address\n *\n * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\n * address.\n *\n * The expected format is zil1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n *\n * @param {string} 20 byte canonical address\n * @returns {string} 38 char bech32 encoded zilliqa address\n */\nexport const toBech32Address = (address: string): string => {\n  if (!validation.isAddress(address)) {\n    throw new Error('Invalid address format.');\n  }\n\n  const addrBz = convertBits(\n    Buffer.from(address.replace('0x', ''), 'hex'),\n    8,\n    5,\n  );\n\n  if (addrBz === null) {\n    throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n  }\n\n  return encode(HRP, addrBz);\n};\n\n/**\n * fromBech32Address\n *\n * @param {string} address - a valid Zilliqa bech32 address\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nexport const fromBech32Address = (address: string): string => {\n  const res = decode(address);\n\n  if (res === null) {\n    throw new Error('Invalid bech32 address');\n  }\n\n  const { hrp, data } = res;\n\n  const shouldBe = HRP;\n  if (hrp !== shouldBe) {\n    throw new Error(`Expected hrp to be ${shouldBe} but got ${hrp}`);\n  }\n\n  const buf = convertBits(data, 5, 8, false);\n\n  if (buf === null) {\n    throw new Error('Could not convert buffer to bytes');\n  }\n\n  return toChecksumAddress(buf.toString('hex'));\n};\n","//  This file is part of Zilliqa-Javascript-Library.\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public License\n//   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport elliptic from 'elliptic';\nimport hashjs from 'hash.js';\n\nimport { BN, validation } from '@zilliqa-js/util';\n\nimport { fromBech32Address, toBech32Address } from './bech32';\n\nconst secp256k1 = elliptic.ec('secp256k1');\n\n/**\n * getAddressFromPrivateKey\n *\n * takes a hex-encoded string (private key) and returns its corresponding\n * 20-byte hex-encoded address.\n *\n * @param {string} privateKey\n * @returns {string}\n */\nexport const getAddressFromPrivateKey = (privateKey: string): string => {\n  const normalizedPrviateKey = normalizePrivateKey(privateKey);\n  const keyPair = secp256k1.keyFromPrivate(normalizedPrviateKey, 'hex');\n  const pub = keyPair.getPublic(true, 'hex');\n\n  return toChecksumAddress(\n    hashjs\n      .sha256()\n      .update(pub, 'hex')\n      .digest('hex')\n      .slice(24),\n  );\n};\n\n/**\n * getPubKeyFromPrivateKey\n *\n * takes a hex-encoded string (private key) and returns its corresponding\n * hex-encoded 33-byte public key.\n *\n * @param {string} privateKey\n * @returns {string}\n */\nexport const getPubKeyFromPrivateKey = (privateKey: string) => {\n  const normalizedPrviateKey = normalizePrivateKey(privateKey);\n  const keyPair = secp256k1.keyFromPrivate(normalizedPrviateKey, 'hex');\n  return keyPair.getPublic(true, 'hex');\n};\n\n/**\n * getAccountFrom0xPrivateKey\n *\n * Utility method for recovering account from 0x private key.\n * See https://github.com/Zilliqa/Zilliqa-JavaScript-Library/pull/159\n * @param privateKeyWith0x : private key with 0x prefix\n */\n\nexport const getAccountFrom0xPrivateKey = (privateKeyWith0x: string) => {\n  const privateKeyWithout0x = normalizePrivateKey(privateKeyWith0x);\n  const keyPair = secp256k1.keyFromPrivate(privateKeyWith0x, 'hex');\n  const publicKeyWith0x = keyPair.getPublic(true, 'hex');\n  const addressWith0x = getAddressFromPublicKey(publicKeyWith0x);\n  const bech32With0x = toBech32Address(addressWith0x);\n  const with0x = {\n    prv: privateKeyWith0x,\n    pub: publicKeyWith0x,\n    addr: addressWith0x,\n    bech32: bech32With0x,\n  };\n\n  const keyPair2 = secp256k1.keyFromPrivate(privateKeyWithout0x, 'hex');\n  const publicKeyWithout0x = keyPair2.getPublic(true, 'hex');\n  const addressWithout0x = getAddressFromPublicKey(publicKeyWithout0x);\n  const bech32Without0x = toBech32Address(addressWithout0x);\n  const without0x = {\n    prv: privateKeyWithout0x,\n    pub: publicKeyWithout0x,\n    addr: addressWithout0x,\n    bech32: bech32Without0x,\n  };\n\n  const privateKeyAfterChange = keyPair.getPrivate('hex');\n  const publicKeyAfterChange = keyPair.getPublic(true, 'hex');\n  const addressAfterChange = getAddressFromPublicKey(publicKeyAfterChange);\n  const bech32AfterChange = toBech32Address(addressAfterChange);\n\n  const changed = {\n    prv: privateKeyAfterChange,\n    pub: publicKeyAfterChange,\n    addr: addressAfterChange,\n    bech32: bech32AfterChange,\n  };\n\n  return {\n    with0x,\n    without0x,\n    changed,\n  };\n};\n\n/**\n * compressPublicKey\n *\n * @param {string} publicKey - 65-byte public key, a point (x, y)\n *\n * @returns {string}\n */\nexport const compressPublicKey = (publicKey: string): string => {\n  return secp256k1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');\n};\n\n/**\n * getAddressFromPublicKey\n *\n * takes hex-encoded string and returns the corresponding address\n *\n * @param {string} pubKey\n * @returns {string}\n */\nexport const getAddressFromPublicKey = (publicKey: string) => {\n  return toChecksumAddress(\n    hashjs\n      .sha256()\n      .update(publicKey, 'hex')\n      .digest('hex')\n      .slice(24),\n  );\n};\n\n/**\n * toChecksumAddress\n *\n * takes hex-encoded string and returns the corresponding address\n *\n * @param {string} address\n * @returns {string}\n */\nexport const toChecksumAddress = (address: string): string => {\n  if (!validation.isAddress(address)) {\n    throw new Error(`${address} is not a valid base 16 address`);\n  }\n\n  address = address.toLowerCase().replace('0x', '');\n  const hash = hashjs\n    .sha256()\n    .update(address, 'hex')\n    .digest('hex');\n  const v = new BN(hash, 'hex', 'be');\n  let ret = '0x';\n\n  for (let i = 0; i < address.length; i++) {\n    if ('0123456789'.indexOf(address[i]) !== -1) {\n      ret += address[i];\n    } else {\n      ret += v.and(new BN(2).pow(new BN(255 - 6 * i))).gte(new BN(1))\n        ? address[i].toUpperCase()\n        : address[i].toLowerCase();\n    }\n  }\n\n  return ret;\n};\n\n/**\n * isValidChecksumAddress\n *\n * takes hex-encoded string and returns boolean if address is checksumed\n *\n * @param {string} address\n * @returns {boolean}\n */\nexport const isValidChecksumAddress = (address: string): boolean => {\n  return (\n    validation.isAddress(address.replace('0x', '')) &&\n    toChecksumAddress(address) === address\n  );\n};\n\n/**\n * normaliseAddress\n *\n * takes in a base16 address or a zilliqa bech32 encoded address\n * and returns a checksum base16 address. If the address is neither a base16\n * nor bech32 address, the code will return an error\n * @param {string)} address\n * @returns {string}\n */\nexport const normaliseAddress = (address: string): string => {\n  if (validation.isBech32(address)) {\n    return fromBech32Address(address);\n  }\n\n  if (!isValidChecksumAddress(address)) {\n    throw Error(\n      'Wrong address format, should be either bech32 or checksummed address',\n    );\n  }\n\n  return address;\n};\n\n/**\n * encodeBase58\n *\n * @param {string} hex - base 16 encoded string\n * @returns {string} - big endian base 58 encoded string\n */\nexport const encodeBase58 = (hex: string): string => {\n  const clean = hex.toLowerCase().replace('0x', '');\n  const tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n  const base = new BN(58);\n  const zero = new BN(0);\n  let x = new BN(clean, 16);\n  let res = '';\n\n  while (x.gt(zero)) {\n    const rem = x.mod(base).toNumber(); // safe, always < 58\n    // big endian\n    res = tbl[rem] + res;\n    // quotient, remainders thrown away in integer division\n    x = x.div(base);\n  }\n\n  // convert to big endian in case the input hex is little endian\n  const hexBE = x.toString('hex', clean.length);\n  for (let i = 0; i < hexBE.length; i += 2) {\n    if (hex[i] === '0' && hex[i + 1] === '0') {\n      res = tbl[0] + res;\n    } else {\n      break;\n    }\n  }\n\n  return res;\n};\n\n/**\n * decodeBase58\n *\n * @param {string} raw - base 58 string\n * @returns {string} - big endian base 16 string\n */\nexport const decodeBase58 = (raw: string): string => {\n  const tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n  const base = new BN(58);\n  const zero = new BN(0);\n  let isBreak = false;\n  let n = new BN(0);\n  let leader = '';\n\n  for (let i = 0; i < raw.length; i++) {\n    const char = raw.charAt(i);\n    const weight = new BN(tbl.indexOf(char));\n    n = n.mul(base).add(weight);\n\n    // check if padding required\n    if (!isBreak) {\n      if (i - 1 > 0 && raw[i - 1] !== '1') {\n        isBreak = true;\n        continue;\n      }\n      if (char === '1') {\n        leader += '00';\n      }\n    }\n  }\n  if (n.eq(zero)) {\n    return leader;\n  }\n\n  let res = leader + n.toString('hex');\n  if (res.length % 2 !== 0) {\n    res = '0' + res;\n  }\n\n  return res;\n};\n\n/**\n * verifyPrivateKey\n *\n * @param {string|Buffer} privateKey\n * @returns {boolean}\n */\nexport const verifyPrivateKey = (privateKey: string): boolean => {\n  const keyPair = secp256k1.keyFromPrivate(privateKey, 'hex');\n  const { result } = keyPair.validate();\n  return result;\n};\n\n/**\n * normalizePrivateKey : normalise private key from 0x or without 0x prefix\n *\n * @param {string} privateKey\n * @returns {string}\n */\n\nexport const normalizePrivateKey = (privateKey: string): string => {\n  try {\n    if (!validation.isPrivateKey(privateKey)) {\n      throw new Error('Private key is not correct');\n    }\n    const normalized = privateKey.toLowerCase().replace('0x', '');\n    if (!verifyPrivateKey(normalized)) {\n      throw new Error('Private key is not correct');\n    }\n    return normalized;\n  } catch (error) {\n    throw error;\n  }\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","module.exports = require('scryptsy')\n","//  This file is part of Zilliqa-Javascript-Library.\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public License\n//   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport aes from 'aes-js';\nimport hashjs from 'hash.js';\nimport { pbkdf2Sync } from 'pbkdf2';\nimport scrypt from 'scrypt.js';\nimport uuid from 'uuid';\n\nimport { bytes } from '@zilliqa-js/util';\n\nimport { randomBytes } from './random';\nimport {\n  KeystoreV3,\n  KDF,\n  KDFParams,\n  PBKDF2Params,\n  ScryptParams,\n} from './types';\nimport { getAddressFromPrivateKey } from './util';\n\nconst ALGO_IDENTIFIER = 'aes-128-ctr';\n\n/**\n * getDerivedKey\n *\n * NOTE: only scrypt and pbkdf2 are supported.\n *\n * @param {Buffer} key - the passphrase\n * @param {KDF} kdf - the key derivation function to be used\n * @param {KDFParams} params - params for the kdf\n *\n * @returns {Promise<Buffer>}\n */\nasync function getDerivedKey(\n  key: Buffer,\n  kdf: KDF,\n  params: KDFParams,\n): Promise<Buffer> {\n  const salt = Buffer.from(params.salt, 'hex');\n\n  if (kdf === 'pbkdf2') {\n    const { c, dklen } = params as PBKDF2Params;\n    return pbkdf2Sync(key, salt, c, dklen, 'sha256');\n  }\n\n  if (kdf === 'scrypt') {\n    const { n, r, p, dklen } = params as ScryptParams;\n    return scrypt(key, salt, n, r, p, dklen);\n  }\n\n  throw new Error('Only pbkdf2 and scrypt are supported');\n}\n\n/**\n * encryptPrivateKey\n *\n * Encodes and encrypts an account in the format specified by\n * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition.\n * However, note that, in keeping with the hash function used by Zilliqa's\n * core protocol, the MAC is generated using sha256 instead of keccak.\n *\n * NOTE: only scrypt and pbkdf2 are supported.\n *\n * @param {KDF} kdf - the key derivation function to be used\n * @param {string} privateKey - hex-encoded private key\n * @param {string} passphrase - a passphrase used for encryption\n *\n * @returns {Promise<string>}\n */\nexport const encryptPrivateKey = async (\n  kdf: KDF,\n  privateKey: string,\n  passphrase: string,\n): Promise<string> => {\n  const address = getAddressFromPrivateKey(privateKey);\n  const salt = randomBytes(32);\n  const iv = Buffer.from(randomBytes(16), 'hex');\n  const kdfparams = {\n    salt,\n    n: 8192,\n    c: 262144,\n    r: 8,\n    p: 1,\n    dklen: 32,\n  };\n\n  const derivedKey = await getDerivedKey(\n    Buffer.from(passphrase),\n    kdf,\n    kdfparams,\n  );\n  const cipher = new aes.ModeOfOperation.ctr(\n    derivedKey.slice(0, 16),\n    new aes.Counter(iv),\n  );\n  const ciphertext = Buffer.from(\n    cipher.encrypt(Buffer.from(privateKey, 'hex')),\n  );\n\n  return JSON.stringify({\n    address,\n    crypto: {\n      cipher: ALGO_IDENTIFIER,\n      cipherparams: {\n        iv: iv.toString('hex'),\n      },\n      ciphertext: ciphertext.toString('hex'),\n      kdf,\n      kdfparams,\n      mac: hashjs\n        // @ts-ignore\n        .hmac(hashjs.sha256, derivedKey, 'hex')\n        .update(\n          Buffer.concat([\n            derivedKey.slice(16, 32),\n            ciphertext,\n            iv,\n            Buffer.from(ALGO_IDENTIFIER),\n          ]),\n          'hex',\n        )\n        .digest('hex'),\n    },\n    id: uuid.v4({ random: bytes.hexToIntArray(randomBytes(16)) }),\n    version: 3,\n  });\n};\n\n/**\n * decryptPrivateKey\n *\n * Recovers the private key from a keystore file using the given passphrase.\n *\n * @param {string} passphrase\n * @param {KeystoreV3} keystore\n * @returns {Promise<string>}\n */\nexport const decryptPrivateKey = async (\n  passphrase: string,\n  keystore: KeystoreV3,\n): Promise<string> => {\n  const ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n  const iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n  const kdfparams = keystore.crypto.kdfparams;\n\n  const derivedKey = await getDerivedKey(\n    Buffer.from(passphrase),\n    keystore.crypto.kdf,\n    kdfparams,\n  );\n\n  const mac = hashjs\n    // @ts-ignore\n    .hmac(hashjs.sha256, derivedKey, 'hex')\n    .update(\n      Buffer.concat([\n        derivedKey.slice(16, 32),\n        ciphertext,\n        iv,\n        Buffer.from(ALGO_IDENTIFIER),\n      ]),\n      'hex',\n    )\n    .digest('hex');\n\n  // we need to do a byte-by-byte comparison to avoid non-constant time side\n  // channel attacks.\n  if (!bytes.isEqual(mac.toUpperCase(), keystore.crypto.mac.toUpperCase())) {\n    return Promise.reject('Failed to decrypt.');\n  }\n\n  const cipher = new aes.ModeOfOperation.ctr(\n    derivedKey.slice(0, 16),\n    new aes.Counter(iv),\n  );\n\n  return Buffer.from(cipher.decrypt(ciphertext)).toString('hex');\n};\n","//  This file is part of Zilliqa-Javascript-Library.\n//\n//  This program is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public License\n//   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nimport * as schnorr from './schnorr';\n\n/**\n * sign\n *\n * @param {string} hash - hex-encoded hash of the data to be signed\n *\n * @returns {string} the signature\n */\nexport const sign = (\n  msg: Buffer,\n  privateKey: string,\n  pubKey: string,\n): string => {\n  const sig = schnorr.sign(\n    msg,\n    Buffer.from(privateKey, 'hex'),\n    Buffer.from(pubKey, 'hex'),\n  );\n\n  let r = sig.r.toString('hex');\n  let s = sig.s.toString('hex');\n  while (r.length < 64) {\n    r = '0' + r;\n  }\n  while (s.length < 64) {\n    s = '0' + s;\n  }\n\n  return r + s;\n};\n\nexport { schnorr };\nexport * from './util';\nexport * from './keystore';\nexport * from './random';\nexport * from './types';\nexport * from './signature';\nexport * from './bech32';\n"]},"metadata":{},"sourceType":"script"}